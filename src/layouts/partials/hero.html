
{{ $events := .Site.Data.events.payload }}
{{ $max_temp := .Site.Data.max_temp_20230717.features }}

<div class="container text-center pt-4 pb-2">
  <h2>Recorded Temperature Visualizer</h2>
</div>
<section class="d-flex flex-row">
<section class="d-flex flex-column p-2">
  <!-- TODO: Need to update map and controls when this changes -->
  <label>Temperature units</label>
  <div class="input-group mb-3">
    <input type="radio" class="btn-check" name="temp_units" id="C" autocomplete="off">
    <label class="btn btn-secondary" for="C" onclick='setTempUnit("C")'>C</label>

    <input type="radio" class="btn-check" name="temp_units" id="F" autocomplete="off" checked>
    <label class="btn btn-secondary" for="F" onclick='setTempUnit("F")'>F</label>
  </div>

  <hr/>

  <label for="min_temp">Minimum temperature</label>
  <div class="range-wrap">
    <div class="range-value" id="min_temp_tooltip"></div>
    <input type="range" class="form-range" id="min_temp" 
      min="100" max="120" value="100"
      onchange="filterMarkers()"/>
  </div>

  <hr/>

  <label for="date_range">Date Range</label>
  <select name="date_range" id="date_range" onchange="filterMarkers()">
    <option value="1">Past 24 hours</option>
    <option value="7" selected>Past week</option>
    <option value="31">Past month</option>
  </select>
</section>

<section class="hero" id="home">
  <div id="map"></div>
</section>
</section>

<script>
  const _TMAX = 'TMAX'
  const _TLOW = 'TLOW'
  const _FILTER_EVENT_ALL = 'all_temp'
  const _FILTER_EVENT_TMAX = _TMAX
  const _FILTER_EVENT_TLOW = _TLOW
  const _FILTER_DATE_PAST_DAY = 'past_day'
  const _FILTER_DATE_PAST_WEEK = 'past_week'
  const _FILTER_DATE_PAST_MONTH = 'past_month'
  //let events = {{ $events }};
  let events = {{ $max_temp }};
  // Holds places to aggregate multiple temperature points
  let places = { }
  let unit = 'F'

  function getTempUnit() {
    return `Â°${unit}`
  }

  function setTempUnit(u) {
    unit = u
  }

  // Get temperature in correct units
  function getTempValue(v) {
    if (unit == 'F') return v
    let c = (v - 32) * 5 / 9
    return Math.round(c*10)/10
  }

  const 
    min_temp_range = document.getElementById('min_temp'),
    min_temp_tooltip = document.getElementById('min_temp_tooltip')

  function setMaxTempTooltip() {
    const
      value = Number( (min_temp_range.value - min_temp_range.min) * 100 / (min_temp_range.max - min_temp_range.min) ),
      position = 10 - (value * 0.2);

    min_temp_tooltip.innerHTML = `<span>${getTempValue(min_temp_range.value)} ${getTempUnit()}</span>`;
    min_temp_tooltip.style.left = `calc(${value}% + (${position}px))`;
  }

  document.addEventListener("DOMContentLoaded", setMaxTempTooltip)
  min_temp_range.addEventListener("input", setMaxTempTooltip)
  
  // function foo() {
  //   events.forEach(element => {
  //     element.properties.date = '2023-07-12'
  //     element.properties.place_type = 'CITY'
  //     element.properties.event = 'TMAX'
  //     let lat = element.geometry.coordinates[0]
  //     let lng = element.geometry.coordinates[1]
  //     element.geometry.coordinates[0] = lng
  //     element.geometry.coordinates[1] = lat
  //   });
  //   // console.log(events)
  //   // str_arr = events.map((element) => {JSON.stringify(element)})
  //   // newArray = str_arr.map((x) => JSON.parse(x))
  //   // console.log(JSON.stringify(events))
  // }
  // foo()

  var tiles = L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', {
      maxZoom: 15,
      attribution: '&copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a>'
  });
  var map = L.map('map').addLayer(tiles);

  var markers = L.markerClusterGroup();
  
  var popup = L.popup();

  // Use this for a precipitation overlay
  function load_raster_ovelay() {
    d3.request("/data/precipitation.tif").responseType('arraybuffer').get(
      function (error, tiffData) {
        console.log(`TIFF error: {error}`)
        let dem = L.ScalarField.fromGeoTIFF(tiffData.response);
        let layerDem = L.canvasLayer.scalarField(dem, {
            color: chroma.scale('Spectral').domain([80, 0])
        }).addTo(map);

        map.fitBounds(layerDem.getBounds());

        /* dynamic filtering */
        filter_fn = function(v) { return v > 1 }
        layerDem.setFilter(filter_fn)
        /*
        let height = document.getElementById('height');
        height.addEventListener('change', function () {
          let h = height.value;
          let f = function (v) {
              return v >= 0 && v <= h;
          };
          layerDem.setFilter(f);
          document.getElementById('meters').innerHTML = '< ' + h + ' m'
        });
        */

        /* popup */
        /*
        layerDem.on('click', function (e) {
          if (e.value !== null) {
            let v = e.value.toFixed(1);
            let html = (`<span class="popupText">${v} meters</span>`);
            let popup = L.popup()
                .setLatLng(e.latlng)
                .setContent(html)
                .openOn(map);
          }
        });
        */
      });
    }

  // function onMapClick(e) {
  //   popup
  //       .setLatLng(e.latlng)
  //       .setContent("You clicked the map at " + e.latlng.toString())
  //       .openOn(map);
  // }

  // map.on('click', onMapClick);

  function generateHTMLHeadline(props) {
    // const placeType = props.place_type
    //const event = props.event == 'TMAX' ? 'max temperature' : 'low temperature'; 
    let content = `<strong>${props.name}</strong>
      <hr>
      <p>
      Max temp on ${props.date_str}: <strong>${getTempValue(props.max)}</strong> ${getTempUnit()}.
      </p>
    `
    return content

  }
  
  function addPopups(feature, layer) {
    let props = feature.properties
    if (props) {
      let label = `${getTempValue(feature.properties.max)} ${getTempUnit()}`
      layer.bindPopup(generateHTMLHeadline(feature.properties))
      layer.bindTooltip(label, {
        permanent: true,
        direction: 'auto',
        className: "my-labels",
        opacity: 1
      }).openTooltip()
    }
  }

  function createCustomMarker(feature, latlng) {
    /*
    let customIcon = L.icon({
      iconUrl: "/images/icons/marker.png",
      iconSize: [35, 35],
      popupAnchor: [0, 0]
    })
    return L.marker(latlng, { icon: customIcon })
    */

    let radius = 10
    let color = '#BB2222'
    let weight = 1

    if (feature.properties.max >= 120) {
      color = '#FF0000'
      weight = 2
    }

    let marker = L.circleMarker(latlng, {
      color: color,
      radius: radius,
      weight: weight
    })
    marker.on('mouseover', function() {
      let props = this.feature.properties
      console.log("mouseover event: ")
      console.log(props)

      // TODO: construct label using places variable
      //this.getPopup().setContent('foo')
    })
    return marker
  }

  function getPastDate(days) {
    let date = new Date()
    date.setDate(date.getDate() - days)
    return date
  }

  function filterDate(feature, layer, min_date) {
    const props = feature.properties
    let date = new Date(props.date)
    //console.log(`Point date: ${date}`)
    return date.getTime() >= min_date.getTime()
  }

  function filterTemp(feature, layer, min_temp) {
    const props = feature.properties
    return props.max >= min_temp
  }
  
  function resetPlaces() {
    places = { }
  }

  function getPlace(name) {
    return places[name]
  }

  function hasPlace(name) {
    return places[name] !== undefined
  }

  function putPlace(name, date, temp) {
    if (hasPlace(name)) {
      places[name][date] = temp
    } else {
      places[name] = {date: temp}
    }
  }

  function displayMarkers(min_temp, days) {
    let min_date = getPastDate(days)
    console.log(`Got min_date: ${min_date}`)

    var geoJsonLayer = L.geoJSON(events, {
      pointToLayer: createCustomMarker,
      filter: (feature, layer) => {
        date_mask = filterDate(feature, layer, min_date)
        temp_mask = filterTemp(feature, layer, min_temp)
        if (! (date_mask && temp_mask)) return false

        let props = feature.properties
        if (hasPlace(props.name)) {
          putPlace(props.name, props.date, props.max)
          return false
        }

        putPlace(props.name, props.date, props.max)
        return true
      },
      onEachFeature: addPopups
    })

    markers.addLayer(geoJsonLayer)
    map.addLayer(markers)
    if (Object.keys(markers.getBounds()).length == 0) {
      return map.setView([39.997519, -95.185547], 5)
    }
    map.fitBounds(markers.getBounds())
  }

  function removeMarkers() {
    markers.clearLayers();
    resetPlaces()
  }
  
  function filterMarkers() {
    const min_temp = $('#min_temp').val();
    const days = $('#date_range').find(":selected").val();
    //console.log(`Min temp: ${min_temp}`)

    removeMarkers();
    displayMarkers(min_temp, days);
  }

  function getPastDay() {
    return moment().subtract(1, 'days').format('YYYY-MM-DD');
  }

  function getPastWeek() {
    return moment().subtract(1, 'weeks').format('YYYY-MM-DD');
  }

  function getPastMonth() {
    return moment().subtract(1, 'months').format('YYYY-MM-DD');
  }

  filterMarkers()
  

</script>
